# 自我介绍
🥰嗨，我的昵称是***Summer186***，因为一年之中我最喜欢夏天。

👩我的真名是**马珺瑶**。我来自新媒体学院数字媒体技术专业一班，并担任班级团支书一职。

* 1、兴趣爱好:
✨我擅长弹钢琴，还喜欢唱歌、旅行和看电影。

* 2、想加入414社团的原因:
🌱我对建模和代码比较感兴趣。但是由于目前学习的知识有限，所以想加入414社团，了解更多关于这方面的知识，学会运用相关软件。加入414社团后，我会在完成项目的同时学习更多关于建模和代码的知识，有不明白的地方及时查询资料或询问学姐学长和老师。同时，我也希望能在老师的指导下，参加更多有关这方面的比赛，并取得好成绩。

* 3、喜欢的图片:

![](https://github.com/Summer186/Ma-Junyao_414join/blob/main/file01/1.jfif)


# 冒泡算法的过程
* 1、原理：
以从小到大排序为例，冒泡排序的整体思想是这样的：
从数组头部开始，不断比较相邻的两个元素的大小，让较大的元素逐渐往后移动（交换两个元素的值），直到数组的末尾。经过第一轮的比较，就可以找到最大的元素，并将它移动到最后一个位置。
第一轮结束后，继续第二轮。仍然从数组头部开始比较，让较大的元素逐渐往后移动，直到数组的倒数第二个元素为止。经过第二轮的比较，就可以找到次大的元素，并将它放到倒数第二个位置。
以此类推，进行 n-1（n 为数组长度）轮“冒泡”后，就可以将所有的元素都排列好。
整个排序过程就好像气泡不断从水里冒出来，最大的先出来，次大的第二出来，最小的最后出来，所以将这种排序方式称为冒泡排序。

* 2、流程图：
![](https://github.com/Summer186/Ma-Junyao_414join/blob/main/file01/%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95.jfif)

* 3、代码（C语言）：
 
#include <stdio.h>
int main(void)
{
    int nums[10] = {4, 5, 2, 10, 7, 1, 8, 3, 6, 9};    
    int i, j, temp; 
    //冒泡排序算法：进行 n-1 轮比较  
    for(i=0; i<10-1; i++)   
    {   
    //每一轮比较前 n-1-i 个，也就是说，已经排序好的最后 i 个不用比较   
       for(j=0; j<10-1-i; j++)      
       {     
           if(nums[j] > nums[j+1])        
           {          
           temp = nums[j];         
           nums[j] = nums[j+1];         
           nums[j+1] = temp;          
           }  
        }        
   //输出排序后的数组   
   for(i=0; i<10; i++)   
   {   
       printf("%d ", nums[i]);       
   }
   printf("\n");   
   return 0;   
}

* 4、优化算法：
1.#include <stdio.h>
2.int main(void){
3.    int nums[10] = {4, 5, 2, 10, 7, 1, 8, 3, 6, 9};
4.    int i, j, temp, isSorted;
5.   
6.    //优化算法：最多进行 n-1 轮比较
7.    for(i=0; i<10-1; i++){
8.        isSorted = 1;  //假设剩下的元素已经排序好了
9.        for(j=0; j<10-1-i; j++){
10.            if(nums[j] > nums[j+1]){
11.                temp = nums[j];
12.                nums[j] = nums[j+1];
13.                nums[j+1] = temp;
14.                isSorted = 0;  //一旦需要交换数组元素，就说明剩下的元素没有排序好
15.            }
16.        }
17.        if(isSorted) break; //如果没有发生交换，说明剩下的元素已经排序好了
18.    }
19.
20.    for(i=0; i<10; i++){
21.        printf("%d ", nums[i]);
22.    }
23.    printf("\n");
24.   
25.    return 0;
26.}

优化算法优点：当比较到第 i 轮的时候，如果剩下的元素已经排序好了，那么就不用再继续比较了，跳出循环即可，这样就减少了比较的次数，提高了执行效率。


# C4D建模动画
目前处于学习阶段，因为学习内容较少，该视频是学习范例制作。使用软件为Maxon Cinema 4D R21。
视频保存在仓库里。
